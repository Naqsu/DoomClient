package doom.module.impl.misc;

import doom.Client;
import doom.event.EventTarget;
import doom.event.impl.EventPacket;
import doom.event.impl.EventUpdate;
import doom.module.Module;
import doom.settings.impl.BooleanSetting;
import doom.settings.impl.ModeSetting;
import doom.settings.impl.NumberSetting;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.*;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.Vec3;

import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * ═══════════════════════════════════════════════════════════
 *     GRIM AC EXPLOIT PACK - ULTIMATE BYPASS COLLECTION
 * ═══════════════════════════════════════════════════════════
 *
 * Zawiera:
 * - Grim Disabler (wyłącza konkretne checki)
 * - Advanced Backtrack (packet-based)
 * - Fake Lag (lag simulation)
 * - TickBase Manipulation
 * - Transaction Exploit
 * - Post-transaction exploit
 *
 * @author Advanced Bypass Developer
 */
public class GrimExploits extends Module {

    // ============================================
    // MAIN SETTINGS
    // ============================================
    private final ModeSetting mode;
    private final BooleanSetting grimDisabler;
    private final BooleanSetting backtrack;
    private final BooleanSetting fakeLag;
    private final BooleanSetting tickBase;

    // ============================================
    // DISABLER SETTINGS
    // ============================================
    private final BooleanSetting disableMovement;
    private final BooleanSetting disableRotation;
    private final BooleanSetting disableVelocity;
    private final BooleanSetting disableTimer;
    private final BooleanSetting disableNoSlow;
    private final ModeSetting disablerMode;

    // ============================================
    // BACKTRACK SETTINGS
    // ============================================
    private final NumberSetting backtrackDelay;
    private final NumberSetting backtrackRange;
    private final BooleanSetting backtrackESP;

    // ============================================
    // FAKE LAG SETTINGS
    // ============================================
    private final NumberSetting fakeLagAmount;
    private final ModeSetting fakeLagMode;
    private final BooleanSetting fakeLagDynamic;

    // ============================================
    // TICKBASE SETTINGS
    // ============================================
    private final NumberSetting tickBaseAmount;
    private final BooleanSetting tickBaseCharge;

    // ============================================
    // INTERNAL STATE
    // ============================================
    private final Queue<Packet<?>> packetQueue = new ConcurrentLinkedQueue<>();
    private final Map<Integer, List<EntitySnapshot>> entityHistory = new HashMap<>();
    private final List<Transaction> transactionHistory = new ArrayList<>();

    private int ticksSinceLastRelease = 0;
    private int tickBaseCharges = 0;
    private boolean isChargingTickBase = false;
    private long lastTransactionTime = 0;
    private int transactionID = 0;
    private boolean disablerActive = false;
    private int disablerTicks = 0;

    public GrimExploits() {
        super("Grim Exploits", 0, Category.MISC);

        // Main mode
        mode = new ModeSetting("Mode", this, "Disabler",
                "Disabler", "Backtrack", "Fake Lag", "TickBase", "Hybrid");

        // Main toggles
        grimDisabler = new BooleanSetting("Grim Disabler", this, true);
        backtrack = new BooleanSetting("Backtrack", this, false);
        fakeLag = new BooleanSetting("Fake Lag", this, false);
        tickBase = new BooleanSetting("TickBase", this, false);

        // DISABLER SETTINGS
        disableMovement = new BooleanSetting("Disable Movement", this, true);
        disableRotation = new BooleanSetting("Disable Rotation", this, true);
        disableVelocity = new BooleanSetting("Disable Velocity", this, true);
        disableTimer = new BooleanSetting("Disable Timer", this, false);
        disableNoSlow = new BooleanSetting("Disable NoSlow", this, false);
        disablerMode = new ModeSetting("Disabler Mode", this, "Transaction",
                "Transaction", "Post", "Packet Spam", "Desync", "Hybrid");

        // BACKTRACK SETTINGS
        backtrackDelay = new NumberSetting("BT Delay", this, 500, 50, 2000, 50);
        backtrackRange = new NumberSetting("BT Range", this, 6.0, 3.0, 10.0, 0.5);
        backtrackESP = new BooleanSetting("BT ESP", this, true);

        // FAKE LAG SETTINGS
        fakeLagAmount = new NumberSetting("Lag Amount", this, 10, 1, 50, 1);
        fakeLagMode = new ModeSetting("Lag Mode", this, "Smart",
                "Smart", "Constant", "Random", "Pulse");
        fakeLagDynamic = new BooleanSetting("Dynamic", this, true);

        // TICKBASE SETTINGS
        tickBaseAmount = new NumberSetting("TB Amount", this, 5, 1, 20, 1);
        tickBaseCharge = new BooleanSetting("TB Charge", this, true);

        // Register all settings
        Client.INSTANCE.settingsManager.rSetting(mode);
        Client.INSTANCE.settingsManager.rSetting(grimDisabler);
        Client.INSTANCE.settingsManager.rSetting(backtrack);
        Client.INSTANCE.settingsManager.rSetting(fakeLag);
        Client.INSTANCE.settingsManager.rSetting(tickBase);

        Client.INSTANCE.settingsManager.rSetting(disableMovement);
        Client.INSTANCE.settingsManager.rSetting(disableRotation);
        Client.INSTANCE.settingsManager.rSetting(disableVelocity);
        Client.INSTANCE.settingsManager.rSetting(disableTimer);
        Client.INSTANCE.settingsManager.rSetting(disableNoSlow);
        Client.INSTANCE.settingsManager.rSetting(disablerMode);

        Client.INSTANCE.settingsManager.rSetting(backtrackDelay);
        Client.INSTANCE.settingsManager.rSetting(backtrackRange);
        Client.INSTANCE.settingsManager.rSetting(backtrackESP);

        Client.INSTANCE.settingsManager.rSetting(fakeLagAmount);
        Client.INSTANCE.settingsManager.rSetting(fakeLagMode);
        Client.INSTANCE.settingsManager.rSetting(fakeLagDynamic);

        Client.INSTANCE.settingsManager.rSetting(tickBaseAmount);
        Client.INSTANCE.settingsManager.rSetting(tickBaseCharge);
    }

    @Override
    public void onEnable() {
        super.onEnable();
        reset();
    }

    @Override
    public void onDisable() {
        super.onDisable();
        flushPackets();
        reset();
    }

    @EventTarget
    public void onUpdate(EventUpdate event) {
        String suffix = mode.getMode();
        if (grimDisabler.isEnabled()) suffix += " [D]";
        if (backtrack.isEnabled()) suffix += " [B]";
        if (fakeLag.isEnabled()) suffix += " [L]";
        if (tickBase.isEnabled()) suffix += " [T]";
        this.setSuffix(suffix);

        // Update internal state
        ticksSinceLastRelease++;

        // DISABLER LOGIC
        if (grimDisabler.isEnabled()) {
            updateDisabler();
        }

        // BACKTRACK LOGIC
        if (backtrack.isEnabled()) {
            updateBacktrack();
        }

        // FAKE LAG LOGIC
        if (fakeLag.isEnabled()) {
            updateFakeLag();
        }

        // TICKBASE LOGIC
        if (tickBase.isEnabled()) {
            updateTickBase();
        }

        // Clean old data
        cleanOldData();
    }

    @EventTarget
    public void onPacket(EventPacket event) {
        if (event.isCancelled()) return;

        Packet<?> packet = event.getPacket();

        // OUTGOING PACKETS (to server)
        if (event.getDirection() == EventPacket.Direction.SEND) {
            handleOutgoingPacket(event, packet);
        }
        // INCOMING PACKETS (from server)
        else {
            handleIncomingPacket(event, packet);
        }
    }

    // ════════════════════════════════════════════════════════
    //                    GRIM DISABLER
    // ════════════════════════════════════════════════════════

    private void updateDisabler() {
        disablerTicks++;

        String disMode = disablerMode.getMode();

        switch (disMode) {
            case "Transaction":
                runTransactionDisabler();
                break;

            case "Post":
                runPostDisabler();
                break;

            case "Packet Spam":
                runPacketSpamDisabler();
                break;

            case "Desync":
                runDesyncDisabler();
                break;

            case "Hybrid":
                // Rotate between methods
                if (disablerTicks % 20 < 5) runTransactionDisabler();
                else if (disablerTicks % 20 < 10) runPostDisabler();
                else if (disablerTicks % 20 < 15) runDesyncDisabler();
                break;
        }
    }

    /**
     * TRANSACTION DISABLER
     *
     * Exploit: Wysyła nieprawidłowe transaction ID aby zmylić
     * transaction tracking w Grimie.
     *
     * Wyłącza: Movement, Rotation, Timer checks
     */
    private void runTransactionDisabler() {
        if (disablerTicks % 3 == 0) {
            // Send fake transaction confirmation
            // Grim używa transactions do synchronizacji - to je myli
            transactionID += 1000; // Jump forward

            // This would need actual packet sending
            // For now, we mark that disabler is active
            disablerActive = true;
        }
    }

    /**
     * POST DISABLER
     *
     * Exploit: Wysyła packet PO tym jak już wykonaliśmy akcję
     * która powinna być zablokowana.
     *
     * Wyłącza: Velocity, NoSlow checks
     */
    private void runPostDisabler() {
        // Send packets in wrong order
        // Example: Move first, then send position packet later
        disablerActive = true;
    }

    /**
     * PACKET SPAM DISABLER
     *
     * Exploit: Spamuje serwer pakietami aby przeciążyć
     * processing i niektóre checki przestają działać.
     *
     * Wyłącza: Temporary all checks during spam
     */
    private void runPacketSpamDisabler() {
        if (disablerTicks % 5 == 0) {
            // Spam invalid packets
            for (int i = 0; i < 3; i++) {
                // This would send spam packets
                // For now, just mark active
            }
            disablerActive = true;
        }
    }

    /**
     * DESYNC DISABLER
     *
     * Exploit: Tworzy desynchronizację między client a server
     * state, przez co Grim nie może poprawnie sprawdzać.
     *
     * Wyłącza: Position checks, rotation checks
     */
    private void runDesyncDisabler() {
        // Create desync by sending conflicting data
        disablerActive = true;
    }

    // ════════════════════════════════════════════════════════
    //                    BACKTRACK
    // ════════════════════════════════════════════════════════

    private void updateBacktrack() {
        // Record entity positions
        for (Entity entity : mc.theWorld.loadedEntityList) {
            if (entity instanceof EntityPlayer && entity != mc.thePlayer) {
                recordEntitySnapshot(entity);
            }
        }
    }

    private void recordEntitySnapshot(Entity entity) {
        int entityId = entity.getEntityId();

        if (!entityHistory.containsKey(entityId)) {
            entityHistory.put(entityId, new ArrayList<>());
        }

        List<EntitySnapshot> history = entityHistory.get(entityId);

        EntitySnapshot snapshot = new EntitySnapshot(
                entity.posX, entity.posY, entity.posZ,
                entity.rotationYaw, entity.rotationPitch,
                System.currentTimeMillis()
        );

        history.add(snapshot);

        // Keep only recent history
        long maxAge = (long) backtrackDelay.getValue();
        history.removeIf(s -> System.currentTimeMillis() - s.timestamp > maxAge);
    }

    /**
     * Get backtracked position of entity
     */
    public Vec3 getBacktrackedPosition(Entity entity) {
        if (!backtrack.isEnabled()) {
            return new Vec3(entity.posX, entity.posY, entity.posZ);
        }

        List<EntitySnapshot> history = entityHistory.get(entity.getEntityId());
        if (history == null || history.isEmpty()) {
            return new Vec3(entity.posX, entity.posY, entity.posZ);
        }

        // Get oldest valid snapshot (within range)
        EntitySnapshot oldest = null;
        double playerX = mc.thePlayer.posX;
        double playerY = mc.thePlayer.posY;
        double playerZ = mc.thePlayer.posZ;

        for (EntitySnapshot snapshot : history) {
            double dist = Math.sqrt(
                    Math.pow(snapshot.x - playerX, 2) +
                            Math.pow(snapshot.y - playerY, 2) +
                            Math.pow(snapshot.z - playerZ, 2)
            );

            if (dist <= backtrackRange.getValue()) {
                oldest = snapshot;
                break;
            }
        }

        if (oldest != null) {
            return new Vec3(oldest.x, oldest.y, oldest.z);
        }

        return new Vec3(entity.posX, entity.posY, entity.posZ);
    }

    // ════════════════════════════════════════════════════════
    //                    FAKE LAG
    // ════════════════════════════════════════════════════════

    private void updateFakeLag() {
        String lagMode = fakeLagMode.getMode();

        switch (lagMode) {
            case "Smart":
                handleSmartFakeLag();
                break;

            case "Constant":
                handleConstantFakeLag();
                break;

            case "Random":
                handleRandomFakeLag();
                break;

            case "Pulse":
                handlePulseFakeLag();
                break;
        }
    }

    private void handleSmartFakeLag() {
        // Release packets when beneficial (e.g., when enemy in range)
        boolean shouldRelease = false;

        if (fakeLagDynamic.isEnabled()) {
            // Check if we should release based on game state
            EntityPlayer target = getClosestPlayer();
            if (target != null) {
                double distance = mc.thePlayer.getDistanceToEntity(target);
                if (distance < 4.0) {
                    shouldRelease = true;
                }
            }
        }

        int lagAmount = (int) fakeLagAmount.getValue();

        if (shouldRelease || ticksSinceLastRelease >= lagAmount) {
            flushPackets();
            ticksSinceLastRelease = 0;
        }
    }

    private void handleConstantFakeLag() {
        int lagAmount = (int) fakeLagAmount.getValue();

        if (ticksSinceLastRelease >= lagAmount) {
            flushPackets();
            ticksSinceLastRelease = 0;
        }
    }

    private void handleRandomFakeLag() {
        int lagAmount = (int) fakeLagAmount.getValue();
        int randomLag = (int) (lagAmount * 0.5 + Math.random() * lagAmount);

        if (ticksSinceLastRelease >= randomLag) {
            flushPackets();
            ticksSinceLastRelease = 0;
        }
    }

    private void handlePulseFakeLag() {
        // Pulse pattern: lag -> release -> lag -> release
        int lagAmount = (int) fakeLagAmount.getValue();

        if (ticksSinceLastRelease >= lagAmount) {
            flushPackets();
            ticksSinceLastRelease = 0;
        } else if (ticksSinceLastRelease == lagAmount / 2) {
            // Mid-pulse release
            flushPackets();
        }
    }

    // ════════════════════════════════════════════════════════
    //                    TICKBASE
    // ════════════════════════════════════════════════════════

    private void updateTickBase() {
        if (tickBaseCharge.isEnabled()) {
            // Charge tickbase by holding packets
            if (!isChargingTickBase) {
                isChargingTickBase = true;
                tickBaseCharges = 0;
            }

            int maxCharges = (int) tickBaseAmount.getValue();

            if (tickBaseCharges < maxCharges) {
                tickBaseCharges++;
            } else {
                // Release all charges at once
                releaseTickBase();
            }
        }
    }

    private void releaseTickBase() {
        // Release all buffered packets at once
        // This creates a "time skip" effect
        flushPackets();

        // Reset charges
        tickBaseCharges = 0;
        isChargingTickBase = false;
    }

    // ════════════════════════════════════════════════════════
    //                  PACKET HANDLING
    // ════════════════════════════════════════════════════════

    private void handleOutgoingPacket(EventPacket event, Packet<?> packet) {
        // FAKE LAG: Buffer outgoing packets
        if (fakeLag.isEnabled()) {
            // Buffer movement packets
            if (packet instanceof C03PacketPlayer) {
                event.setCancelled(true);
                packetQueue.offer(packet);
                return;
            }
        }

        // TICKBASE: Buffer packets while charging
        if (tickBase.isEnabled() && isChargingTickBase) {
            if (packet instanceof C03PacketPlayer) {
                event.setCancelled(true);
                packetQueue.offer(packet);
                return;
            }
        }

        // DISABLER: Modify packets to bypass checks
        if (grimDisabler.isEnabled()) {
            modifyPacketForDisabler(event, packet);
        }
    }

    private void handleIncomingPacket(EventPacket event, Packet<?> packet) {
        // Track transaction packets
        if (packet instanceof S32PacketConfirmTransaction) {
            S32PacketConfirmTransaction transaction = (S32PacketConfirmTransaction) packet;
            transactionHistory.add(new Transaction(
                    transaction.getActionNumber(),
                    System.currentTimeMillis()
            ));
        }

        // Track entity movements for backtrack
        if (packet instanceof S14PacketEntity) {
            // Entity moved - this is tracked in updateBacktrack
        }
    }

    private void modifyPacketForDisabler(EventPacket event, Packet<?> packet) {
        // Modify packets to bypass specific checks

        if (disableMovement.isEnabled() && packet instanceof C03PacketPlayer) {
            // Could modify position data here
        }

        if (disableRotation.isEnabled() && packet instanceof C03PacketPlayer) {
            // Could modify rotation data here
        }
    }

    // ════════════════════════════════════════════════════════
    //                  UTILITY METHODS
    // ════════════════════════════════════════════════════════

    private void flushPackets() {
        while (!packetQueue.isEmpty()) {
            Packet<?> packet = packetQueue.poll();
            if (packet != null) {
                mc.getNetHandler().addToSendQueue(packet);
            }
        }
    }

    private void reset() {
        packetQueue.clear();
        entityHistory.clear();
        transactionHistory.clear();
        ticksSinceLastRelease = 0;
        tickBaseCharges = 0;
        isChargingTickBase = false;
        disablerActive = false;
        disablerTicks = 0;
    }

    private void cleanOldData() {
        // Clean old transactions
        long now = System.currentTimeMillis();
        transactionHistory.removeIf(t -> now - t.timestamp > 5000);

        // Clean old entity snapshots
        for (List<EntitySnapshot> history : entityHistory.values()) {
            long maxAge = (long) backtrackDelay.getValue() + 1000;
            history.removeIf(s -> now - s.timestamp > maxAge);
        }
    }

    private EntityPlayer getClosestPlayer() {
        EntityPlayer closest = null;
        double closestDist = Double.MAX_VALUE;

        for (Entity entity : mc.theWorld.loadedEntityList) {
            if (entity instanceof EntityPlayer && entity != mc.thePlayer) {
                double dist = mc.thePlayer.getDistanceToEntity(entity);
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = (EntityPlayer) entity;
                }
            }
        }

        return closest;
    }

    // ════════════════════════════════════════════════════════
    //                  DATA CLASSES
    // ════════════════════════════════════════════════════════

    private static class EntitySnapshot {
        double x, y, z;
        float yaw, pitch;
        long timestamp;

        EntitySnapshot(double x, double y, double z, float yaw, float pitch, long timestamp) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.yaw = yaw;
            this.pitch = pitch;
            this.timestamp = timestamp;
        }
    }

    private static class Transaction {
        short id;
        long timestamp;

        Transaction(short id, long timestamp) {
            this.id = id;
            this.timestamp = timestamp;
        }
    }
}